# /routes/work_orders.py
from flask import Blueprint, request, jsonify
from mongoengine import DoesNotExist
from models.WorkOrder import WorkOrder
from models.PlanStep import PlanStep
from datetime import datetime, timezone
from agent.main_agent import Context, run_agent, run_agent_from_step, regenerate_steps_from_issue, execute_steps_automatically

work_orders_bp = Blueprint('work_orders', __name__, url_prefix='/api/work_orders')


@work_orders_bp.route('/confirm_step', methods=['POST'])
def from_step():
    data = request.json
    if not data.get('step_id') or not data.get('work_order_id'):
        return jsonify({"error": "step_id and work_order_id are required"}), 400
    try:
        run_agent_from_step(data.get("step_id"), data.get("work_order_id"))
        return jsonify({"message": "Step confirmed and agent continued processing"}), 200
    except DoesNotExist as e:
        return jsonify({"error": f"WorkOrder or PlanStep not found: {str(e)}"}), 404
    except Exception as e:
        return jsonify({"error": f"An error occurred: {str(e)}"}), 500
# Create WorkOrder
@work_orders_bp.route('/', methods=['POST'])
def create_workorder():
    data = request.json
    # Only accept title and description - other fields are auto-generated by LLM
    # title = data.get("title")  # Commented out - using work_order_title instead
    # description = data.get("description")  # Commented out - using work_order_description instead
    # priority = data.get("priority", "medium")  # Auto-generated by LLM
    # estimated_expertise_level = data.get("estimated_expertise_level", "mid")  # Auto-generated by LLM
    # category = data.get("category", "other")  # Auto-generated by LLM
    
    context = Context(
        work_order_title=data.get("title") or data.get("work_order_title"),
        work_order_description=data.get("description") or data.get("work_order_description") or "",
        messages=[]
    )
    run_agent(context)
    return jsonify({"message": "Work order created and agent started processing"}), 201

# Helper function to ensure datetime has timezone info
def format_datetime(dt):
    if not dt:
        return None
    # If datetime is naive (no timezone), assume it's UTC and make it timezone-aware
    if dt.tzinfo is None:
        dt = dt.replace(tzinfo=timezone.utc)
    return dt.isoformat()

# Get All WorkOrders
@work_orders_bp.route('/', methods=['GET'])
def get_workorders():
    workorders = WorkOrder.objects()
    results = []
    for wo in workorders:
        # Calculate status based on step completion
        steps = PlanStep.objects(work_order=wo).order_by('step_number')
        status = wo.status  # Default to current status
        
        if steps:
            completed_steps = [s for s in steps if s.status == "success"]
            in_progress_steps = [s for s in steps if s.status == "in_progress"]
            
            if len(completed_steps) == len(steps):
                # All steps completed
                status = "completed"
            elif len(completed_steps) > 0 or len(in_progress_steps) > 1:
                # At least one step is complete or in progress
                status = "in_progress"
            else:
                # No steps completed yet
                status = "pending"
            
            # Update work order status if it changed
            if wo.status != status:
                wo.status = status
                wo.updated_at = datetime.now(timezone.utc)
                wo.save()
        
        results.append({
            "id": str(wo.id),
            "title": wo.title,
            "description": wo.description,
            "priority": wo.priority,
            "status": status,
            "estimated_expertise_level": wo.estimated_expertise_level,
            "category": wo.category,
            "created_at": format_datetime(wo.created_at),
            "updated_at": format_datetime(wo.updated_at) or format_datetime(wo.created_at)
        })
    return jsonify(results)

# Report Issue and Regenerate Steps
@work_orders_bp.route('/issue', methods=['POST'])
def report_issue():
    data = request.json
    
    # Validate required fields
    if not data.get('step_id') or not data.get('work_order_id') or not data.get('issue_description'):
        return jsonify({"error": "step_id, work_order_id, and issue_description are required"}), 400
    
    try:
        # Get the work order
        work_order = WorkOrder.objects.get(id=data['work_order_id'])
        
        # Get the problematic step
        problematic_step = PlanStep.objects.get(id=data['step_id'], work_order=work_order)
        
        # Get all plan steps for this work order, ordered by step_number
        all_steps = PlanStep.objects(work_order=work_order).order_by('step_number')
        
        # Get completed steps before the problematic step (for context)
        completed_steps = [
            step for step in all_steps 
            if step.step_number < problematic_step.step_number and step.status == "success"
        ]
        
        # Delete all steps from the problematic step onwards
        steps_to_delete = [
            step for step in all_steps 
            if step.step_number >= problematic_step.step_number
        ]
        
        for step in steps_to_delete:
            step.delete()
        
        # Regenerate steps from the problematic step onwards
        new_steps_data = regenerate_steps_from_issue(
            work_order=work_order,
            issue_description=data['issue_description'],
            from_step_number=problematic_step.step_number,
            completed_steps=completed_steps
        )
        
        # Create new PlanSteps
        new_plan_steps = [
            PlanStep(
                work_order=work_order,
                step_number=step['step_number'],
                description=step['description'],
                executor="undecided",
                status="pending",
                result=None,
                executed_at=None
            ) for step in new_steps_data
        ]
        
        # Bulk insert the new steps
        PlanStep.objects.insert(new_plan_steps)
        
        # Refresh steps from database to get IDs and ensure we have the latest data
        refreshed_steps = PlanStep.objects(work_order=work_order).order_by('step_number')
        steps_to_execute = [
            step for step in refreshed_steps 
            if step.step_number >= problematic_step.step_number
        ]
        
        # Automatically execute the new steps (agent will do what it can)
        first_technician_step = execute_steps_automatically(
            work_order=work_order,
            plan_steps=steps_to_execute,
            start_from_step_number=problematic_step.step_number
        )
        
        # Update work order status if needed
        work_order.updated_at = datetime.now(timezone.utc)
        if work_order.status == "completed":
            work_order.status = "in_progress"
        work_order.save()
        
        return jsonify({
            "message": "Steps regenerated successfully",
            "deleted_steps_count": len(steps_to_delete),
            "new_steps_count": len(new_plan_steps),
            "first_technician_step_id": str(first_technician_step.id) if first_technician_step else None,
            "new_steps": [
                {
                    "id": str(step.id),
                    "step_number": step.step_number,
                    "description": step.description,
                    "status": step.status,
                    "executor": step.executor
                } for step in new_plan_steps
            ]
        }), 200
        
    except DoesNotExist as e:
        return jsonify({"error": f"WorkOrder or PlanStep not found: {str(e)}"}), 404
    except Exception as e:
        return jsonify({"error": f"An error occurred: {str(e)}"}), 500

# Get Single WorkOrder
@work_orders_bp.route('/<string:workorder_id>', methods=['GET'])
def get_workorder(workorder_id):
    try:
        wo = WorkOrder.objects.get(id=workorder_id)
        return jsonify({
            "id": str(wo.id),
            "title": wo.title,
            "description": wo.description,
            "priority": wo.priority,
            "status": wo.status,
            "estimated_expertise_level": wo.estimated_expertise_level,
            "category": wo.category,
            "created_at": format_datetime(wo.created_at),
            "updated_at": format_datetime(wo.updated_at)
        })
    except DoesNotExist:
        return jsonify({"error": "WorkOrder not found"}), 404

# Get Steps for a WorkOrder
@work_orders_bp.route('/<string:workorder_id>/steps', methods=['GET'])
def get_workorder_steps(workorder_id):
    try:
        wo = WorkOrder.objects.get(id=workorder_id)
        steps = PlanStep.objects(work_order=wo).order_by('step_number')
        results = []
        for step in steps:
            results.append({
                "id": str(step.id),
                "step_number": step.step_number,
                "description": step.description,
                "executor": step.executor,
                "status": step.status,
                "result": step.result,
                "executed_at": format_datetime(step.executed_at)
            })
        return jsonify(results)
    except DoesNotExist:
        return jsonify({"error": "WorkOrder not found"}), 404

# Update WorkOrder
@work_orders_bp.route('/<string:workorder_id>', methods=['PUT'])
def update_workorder(workorder_id):
    data = request.json
    try:
        wo = WorkOrder.objects.get(id=workorder_id)
        wo.update(
            title=data.get("title", wo.title),
            description=data.get("description", wo.description),
            priority=data.get("priority", wo.priority),
            estimated_expertise_level=data.get("estimated_expertise_level", wo.estimated_expertise_level),
            category=data.get("category", wo.category),
            status=data.get("status", wo.status),
            updated_at=datetime.now(timezone.utc)
        )
        return jsonify({"message": "WorkOrder updated"})
    except DoesNotExist:
        return jsonify({"error": "WorkOrder not found"}), 404

# Delete WorkOrder
@work_orders_bp.route('/<string:workorder_id>', methods=['DELETE'])
def delete_workorder(workorder_id):
    try:
        wo = WorkOrder.objects.get(id=workorder_id)
        wo.delete()
        return jsonify({"message": "WorkOrder deleted"})
    except DoesNotExist:
        return jsonify({"error": "WorkOrder not found"}), 404
